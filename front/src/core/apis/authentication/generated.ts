//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from "axios";
import axios, { AxiosError } from "axios";

export class AuthenticationClient {
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
	private instance: AxiosInstance;
	private baseUrl: string;

	constructor(baseUrl?: string, instance?: AxiosInstance) {
		this.instance = instance ? instance : axios.create();

		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4001";
	}

	/**
	 * Final register step
	 * @param hash user's password hashed with salt
	 * @return the created user
	 */
	register(username: string, hash: string, cancelToken?: CancelToken | undefined): Promise<User> {
		let url_ = this.baseUrl + "/api/auth/{username}";
		if (username === undefined || username === null) throw new Error("The parameter 'username' must be defined.");
		url_ = url_.replace("{username}", encodeURIComponent("" + username));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(hash);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "POST",
			url: url_,
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processRegister(_response);
			});
	}

	/**
	 * Change user's password
	 * @param hash user's password hashed with salt
	 * @return the created user
	 */
	changePassword(username: string, hash: string, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/auth/{username}";
		if (username === undefined || username === null) throw new Error("The parameter 'username' must be defined.");
		url_ = url_.replace("{username}", encodeURIComponent("" + username));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(hash);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "PUT",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processChangePassword(_response);
			});
	}

	/**
	 * First register step
	 * @return a salt for this username
	 */
	initRegister(username: string, cancelToken?: CancelToken | undefined): Promise<InitRegisterResponse> {
		let url_ = this.baseUrl + "/api/auth/{username}/init";
		if (username === undefined || username === null) throw new Error("The parameter 'username' must be defined.");
		url_ = url_.replace("{username}", encodeURIComponent("" + username));
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "POST",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processInitRegister(_response);
			});
	}

	/**
	 * First step to change user's password
	 * @return a salt for this username
	 */
	initChangePassword(username: string, cancelToken?: CancelToken | undefined): Promise<InitRegisterResponse> {
		let url_ = this.baseUrl + "/api/auth/{username}/init";
		if (username === undefined || username === null) throw new Error("The parameter 'username' must be defined.");
		url_ = url_.replace("{username}", encodeURIComponent("" + username));
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "PUT",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processInitChangePassword(_response);
			});
	}

	/**
	 * Final login step
	 * @return a JWT for this user
	 */
	login(username: string, hash: string, cancelToken?: CancelToken | undefined): Promise<string> {
		let url_ = this.baseUrl + "/api/auth/{username}/login";
		if (username === undefined || username === null) throw new Error("The parameter 'username' must be defined.");
		url_ = url_.replace("{username}", encodeURIComponent("" + username));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(hash);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "POST",
			url: url_,
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processLogin(_response);
			});
	}

	/**
	 * First login step
	 * @return a challenge for this username
	 */
	initLogin(username: string, cancelToken?: CancelToken | undefined): Promise<InitVerifyResponse> {
		let url_ = this.baseUrl + "/api/auth/{username}/login/init";
		if (username === undefined || username === null) throw new Error("The parameter 'username' must be defined.");
		url_ = url_.replace("{username}", encodeURIComponent("" + username));
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "POST",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processInitLogin(_response);
			});
	}

	/**
	 * Verify if Jwt is still valid
	 * @return a JWT for this user
	 */
	verify(cancelToken?: CancelToken | undefined): Promise<boolean> {
		let url_ = this.baseUrl + "/api/auth/jwt/verify";
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "GET",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processVerify(_response);
			});
	}

	/**
	 * Get public RSA key used for Jwt validation
	 * @return a JWT for this user
	 */
	getValidationKey(cancelToken?: CancelToken | undefined): Promise<StringResponse> {
		let url_ = this.baseUrl + "/api/auth/jwt/validation-key";
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "GET",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processGetValidationKey(_response);
			});
	}

	protected processRegister(response: AxiosResponse): Promise<User> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 201) {
			const _responseText = response.data;
			let result201: any = null;
			let resultData201 = _responseText;
			result201 = JSON.parse(resultData201);
			return Promise.resolve<User>(result201);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<User>(null as any);
	}

	protected processChangePassword(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processInitRegister(response: AxiosResponse): Promise<InitRegisterResponse> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<InitRegisterResponse>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<InitRegisterResponse>(null as any);
	}

	protected processInitChangePassword(response: AxiosResponse): Promise<InitRegisterResponse> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<InitRegisterResponse>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<InitRegisterResponse>(null as any);
	}

	protected processLogin(response: AxiosResponse): Promise<string> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<string>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<string>(null as any);
	}

	protected processInitLogin(response: AxiosResponse): Promise<InitVerifyResponse> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<InitVerifyResponse>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<InitVerifyResponse>(null as any);
	}

	protected processVerify(response: AxiosResponse): Promise<boolean> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<boolean>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<boolean>(null as any);
	}

	protected processGetValidationKey(response: AxiosResponse): Promise<StringResponse> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<StringResponse>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<StringResponse>(null as any);
	}
}

export class UsersClient {
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
	private instance: AxiosInstance;
	private baseUrl: string;

	constructor(baseUrl?: string, instance?: AxiosInstance) {
		this.instance = instance ? instance : axios.create();

		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4001";
	}

	/**
	 * Get a specific user
	 */
	get(id: string, cancelToken?: CancelToken | undefined): Promise<User> {
		let url_ = this.baseUrl + "/api/users/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "GET",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processGet(_response);
			});
	}

	/**
	 * Update an user
	 */
	updateUser(id: string, user: User, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/users/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(user);

		let options_: AxiosRequestConfig = {
			data: content_,
			method: "PUT",
			url: url_,
			headers: {
				"Content-Type": "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processUpdateUser(_response);
			});
	}

	/**
	 * Delete an user
	 */
	deleteUser(id: string, cancelToken?: CancelToken | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/users/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "DELETE",
			url: url_,
			headers: {},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processDeleteUser(_response);
			});
	}

	/**
	 * Get all users
	 */
	getAll(cancelToken?: CancelToken | undefined): Promise<User[]> {
		let url_ = this.baseUrl + "/api/users";
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "GET",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processGetAll(_response);
			});
	}

	/**
	 * Get if there is at least one user in database
	 * @return If at least one user exist in database
	 */
	checkIfUsersExist(cancelToken?: CancelToken | undefined): Promise<boolean> {
		let url_ = this.baseUrl + "/api/users/any";
		url_ = url_.replace(/[?&]$/, "");

		let options_: AxiosRequestConfig = {
			method: "POST",
			url: url_,
			headers: {
				Accept: "application/json",
			},
			cancelToken,
		};

		return this.instance
			.request(options_)
			.catch((_error: any) => {
				if (isAxiosError(_error) && _error.response) {
					return _error.response;
				} else {
					throw _error;
				}
			})
			.then((_response: AxiosResponse) => {
				return this.processCheckIfUsersExist(_response);
			});
	}

	protected processGet(response: AxiosResponse): Promise<User> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<User>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<User>(null as any);
	}

	protected processUpdateUser(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processDeleteUser(response: AxiosResponse): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 204) {
			const _responseText = response.data;
			return Promise.resolve<void>(null as any);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<void>(null as any);
	}

	protected processGetAll(response: AxiosResponse): Promise<User[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<User[]>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<User[]>(null as any);
	}

	protected processCheckIfUsersExist(response: AxiosResponse): Promise<boolean> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && typeof response.headers === "object") {
			for (let k in response.headers) {
				if (response.headers.hasOwnProperty(k)) {
					_headers[k] = response.headers[k];
				}
			}
		}
		if (status === 200) {
			const _responseText = response.data;
			let result200: any = null;
			let resultData200 = _responseText;
			result200 = JSON.parse(resultData200);
			return Promise.resolve<boolean>(result200);
		} else if (status !== 200 && status !== 204) {
			const _responseText = response.data;
			return throwException("An unexpected server error occurred.", status, _responseText, _headers);
		}
		return Promise.resolve<boolean>(null as any);
	}
}

export interface UserBase {
	username: string;
	hash?: string | undefined;
	salt?: string | undefined;
	settings: Settings;
	credentials: Credentials;
	authorizations: Authorizations;
	lastConnection?: string | undefined;
	disabled: boolean;
}

export interface User extends UserBase {
	id: string;
	createdAt: string;
}

export interface Settings {
	theme: SettingsType;
}

export enum SettingsType {
	Dark = "Dark",
	Light = "Light",
	System = "System",
}

export interface Credentials {
	github?: Github | undefined;
	docker?: Docker | undefined;
}

export interface Github {
	token: string;
	user: string;
}

export interface Docker {
	username: string;
	password: string;
}

export interface Authorizations {
	authentication: Authentication;
	videyo?: Videyo | undefined;
	sousMarinJaune?: SousMarinJaune | undefined;
}

export interface Authentication {
	roles: AuthenticationRoles[];
}

export enum AuthenticationRoles {
	User = "User",
	Admin = "Admin",
}

export interface Videyo {
	roles: VideyoRole[];
}

export enum VideyoRole {
	User = "User",
	Admin = "Admin",
}

export interface SousMarinJaune {
	roles: SousMarinJauneRole[];
}

export enum SousMarinJauneRole {
	Admin = "Admin",
	User = "User",
}

export interface InitRegisterResponse {
	salt: string;
}

export interface InitVerifyResponse {
	salt: string;
	challenge: string;
}

export interface StringResponse {
	data: string;
}

export class ApiException extends Error {
	override message: string;
	status: number;
	response: string;
	headers: { [key: string]: any };
	result: any;
	protected isApiException = true;

	constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	static isApiException(obj: any): obj is ApiException {
		return obj.isApiException === true;
	}
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
	if (result !== null && result !== undefined) throw result;
	else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
	return obj && obj.isAxiosError === true;
}
